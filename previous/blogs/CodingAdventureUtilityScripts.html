<!DOCTYPE HTML>

<html>

	<head>
		<title>Coding Adventure: Utility Scripts</title>

		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="../css/style.css">
		<link rel="stylesheet" href="../css/blogStyle.css">
		<link rel="stylesheet" href="../css/blogPageStyle.css">
	</head>

	<body>
		<nav>
			<li><a href="../index.html">Home</a></li>
			<li><a href="../projects.html">Projects</a></li>
			<li><a href="../resume.html">R&eacute;sum&eacute;</a></li>
			<li><a href="../blog.html">Blog</a></li>
		</nav>

		<main>
			<article>
				<h1>Coding Adventure: Utility Scripts</h1>
				<h2>A walk through of some scripts I've made</h2>

				<time datetime="27-08-2021">AUG. 27, 2021</time>
				<p>I've been wanting to start a series for my blogs on my coding
				projects just so I can talk about what I've been doing and what
				I've been learning. I thought this would be great way to dig into
				various computer science topics and also allow me to justify going
				back to old projects and rewriting them. I swear a project doesn't
				count to me unless I've rewritten it at least once. So I decided
				to finally start my series of coding adventures which I am totally
				stealing this idea (and name) from
				<a href"https://www.youtube.com/c/SebastianLague/Videos">Sebastian Lague.</a>
				If you haven't seen any of his videos by the way I would recommend
				them because they are very entertaining. Anyway to start off this
				series I'm going to go over a couple of simple scripts I've made
				and talk about what problem they solve and how I went about creating
				them. </p>

				<h3>Todo Comments Are Everywhere</h3>
				<p>I like to put todo comments in my code here and there whenever
				I need to come back to something but I just didn't have the time
				to fix the issue there and then. This does help with finding the
				exact line in a file for where something needs to be looked at but
				it does raise another problem. I forget about the todo comments
				and they end up being littered all around the source code for a
				project. So I ended up writing this little script to find todo
				comments that are littered all over the place:</p>

				<pre>
				<code>
#!/bin/sh

if [ -z $1 ]; then
	grep --color -nTR --exclude-dir={.git,imgui,doom} "TODO" ${HOME}/Dev/
else
	grep --color -nTR --exclude-dir={.git} "TODO" $1
fi
				</code>
				</pre>

				<p>This script is very simple. It first checks if any arguments
				have been supplied. If not then the script will run a grep command
				in my dev directory ignoring any .git directories, the imgui
				directory (I've cloned the repo from GitHub), and the doom
				directory which is where my Doom Emacs files are located. The
				else branch is pretty similar but instead only ignores .git
				directories and runs grep in the specified path. I pass the
				--color option to grep to make the output a bit easier to read.
				The -n option shows the line numbers where the todo comments are
				located, the -T option lines up tabs where possible, and the -R
				option is recursive but it follows symlinks (the -r option doesn't
				do that). And that's it for the todo script! All I have to do when
				I want to check if I've left any of those comments is run the script
				and pass in the path of a project if I want the specific project
				or run the script with no arguments to check all of my projects.</p>

				<h3>Syncing Git Repos Across Devices</h3>
				<p>There are probably a hundred different ways to do this but
				I've written a simple script to keep my Git repos synced across
				different devices. Sometimes I'll either be working on my Windows
				desktop, on a Linux VM, or on my Linux laptop and for obvious
				reasons will want the projects that I'm working on or have worked
				on to be up to date with the most current version. So I've
				written a small script to do this called gitsync:</p>

				<pre>
				<code>
#!/bin/sh

check_repo_commits()
{
	REPO_STATUS=$(git -C $1 status --porcelain)
	RESET='\033[0m'
	GREEN='\033[0;32m'
	RED='\033[0;31m'

	if [ -z "$REPO_STATUS" ]
	then
		echo -e "${GREEN}${1} can be synced. Syncing now...${RESET}"
		git -C $1 pull
		echo -e "\n"
	else
		echo -e "${RED}Unable to sync: ${1}"
		echo -e "Changes must be committed or added${RESET}"
		echo -e "\n"
	fi
}

for dir in $(find ~/Dev/ -maxdepth 2 -type d); do

	# Check if the current dir is a git repo
	[ -d "$dir/.git" ] && check_repo_commits $dir
done

				</code>
				</pre>

				<p>The first thing this script does is loop over all the project
				directories I have in the dev directory. I keep all of my projects
				in a dev directory across all devices so I know this layout will
				be consistent. I also only go up to a max recursion depth of 2 as
				project directories will be no deeper than 2 directories. The next
				thing that the script does is perform a check to see if the current
				directory we are iterating through is a Git directory. If it is
				the second expression of the and operator will be executed. The
				second expression is a function call to the check_repo_commits
				function. This function gets the repos status as a string and the
				performs a check on this string. The -z flag is ShellScript syntax
				for checking if a strings length is zero. If it is then the repo
				can be synced. If not then there are pending changes that need to
				be looked at and the script won't perform a Git pull but instead
				output a message saying that changes to the repo must be looked
				at. I've also added some ANSI escape sequences to the function
				to allow for the output to have colour to it as I find this easier
				to look at when trawling through text logs. If the repo can be
				synced the text output is green but if it can't then the text
				output is red.</p>

				<h3>Blog Code Formatting</h3>
				<p>For my website I try to use as little JavaScript as possible.
				I have a static website and I think having JavaScript on it is
				overkill. Now sadly I do have some JS on my site and that is
				used for the slide shows on my projects page. I'm planning on
				changing that sometime in the future but for now it's only a
				minimal amount of JavaScript so I can live with it. I did find
				that I was running into a problem when showing code snippets
				on blogs though. I had no syntax highlighting for the code. Now
				I could use a JS library to do this for me but that would be
				adding more JavaScript to my website not reducing it. So I decided
				to write a script in Python to add syntax highlighting for me.
				Just as a forewarning I'm not well adversed in Python so this
				might be ugly for people who know a lot about Python. This is just
				how I've written the script and it does what I want it to do
				for now.</p>

				<pre>
				<code>
#!/bin/python

import sys
import re

keywords = [
    "auto",
    "char",
    "const",
    "double",
    "enum",
    "extern",
    "float",
    "int",
    "long",
    "register",
    "short",
    "signed",
    "static",
    "struct",
    "typedef",
    "union",
    "unsigned",
    "void",
    "volatile",
]

statements = [
    "break",
    "case",
    "continue",
    "default",
    "do",
    "else",
    "for",
    "goto",
    "if",
    "return",
    "sizeof",
    "switch",
    "while",
]

# Boolean to keep check if we are in a code tag to format
b_in_code_tag = False

def format_comment(line):
    comment = re.findall("\\/\\/.+", line)
    if len(comment) > 0:
        line = line.replace(comment[0], '&ltspan class="blue">'+comment[0]+'&lt/span>')

    comment = re.findall("\\/\\*.+\\*\\/", line)
    if len(comment) > 0:
        line = line.replace(comment[0], '&ltspan class="blue">'+comment[0]+'&lt/span>')

    return line

def format_multiline_comment(line):

    if re.search("\\/\\*$", line):
        line = line.replace('/*', '&ltspan class="blue">/*')

    if re.search("\\*\\/$", line):
        line = line.replace('*/', '*/&lt/span>')

    return line


def format_numbers(line):
    nums = re.findall("\\b[-+]?[\\d.]+(?:[eE][-+]?\\d+)?[f]?\\b", line)
    for num in nums:
        line = line.replace(num, '&ltspan class="red">'+num+'&lt/span>')

    return line

def format_string(line):
    strings = re.findall("[\"'].+[\"']", line)
    for string in strings:
        line = line.replace(string, '&ltspan class=red>'+string+'&lt/span>')
    return line

def format_keywords(line):
    global keywords

    for word in keywords:
        if re.search("\\b"+word+"\\b", line):
            line = line.replace(word, '&ltspan class="green">'+word+'&lt/span>')

    return line

def format_statements(line):
    global statements

    for word in statements:
        if re.search("\\b"+word+"\\b", line):
            line = line.replace(word, '&ltspan class="yellow">'+word+'&lt/span>')

    return line

def format_includes(line):
    if re.search("#include", line):
        line = line.replace("#include", '&ltspan class="purple">'+"#include"+'&lt/span>')

    return line

def format_macros(line):
    pre_proc = re.findall("#define\\s\\w+", line)
    if len(pre_proc) > 0:
        line = line.replace(pre_proc[0], '&ltspan class="purple">'+pre_proc[0]+'&lt/span>')

    return line

def main():

    if len(sys.argv) == 1:
        print("Please supply a file to format")
        exit()

    if len(sys.argv) > 2:
        print("Only one file can be formatted at a time")
        exit()

    with open(sys.argv[1], 'r+') as f:
        file_source = f.read().splitlines()

        global b_in_code_tag

        # Loop through each line of the file
        for line in range(len(file_source)):

            if "<code" in file_source[line]:
                b_in_code_tag = True


            if b_in_code_tag:
                file_source[line] = format_string(file_source[line])
                file_source[line] = format_numbers(file_source[line])
                file_source[line] = format_keywords(file_source[line])
                file_source[line] = format_statements(file_source[line])
                file_source[line] = format_includes(file_source[line])
                file_source[line] = format_macros(file_source[line])
                file_source[line] = format_comment(file_source[line])
                file_source[line] = format_multiline_comment(file_source[line])

            if "</code>" in file_source[line]:
                b_in_code_tag = False

        f.seek(0)
        f.write('\n'.join(file_source))
        f.close()

main()
				</code>
				</pre>

				<p>So how this script works is pretty simple. It has a list of
				language keywords and language statements (these have different
				syntax highlighting in most editors). The script will read in a
				blog and split the file into an array of strings. From here the
				script will iterate through each line looking for a html code tag.
				Once it finds a code tag it switches a boolean value to true
				indicating we are in a block of text that we need to format.
				From there it will call a bunch of formatting functions which
				simply wrap a keyword, statement, number, or string in span tags
				and put the correct class in the span tag so that the text
				gets highlighted correctly. The script then checks for a closing
				code tag and when it finds one it sets the boolean flag to false
				to let the script know that we shouldn't try to perform any
				formatting. Once the script has finished iterating it then
				overwrites the file with the new changes. Now at the moment
				this script is very simple. It only formats code for C and nothing
				else so right now none of the scripts I'm showing will have
				syntax highlighting. I do plan to add support for other languages
				in the script so I might end up doing a coding adventure post
				about how I went about doing that. That will do for now. All of
				these scripts are available on my <a href="https://github.com/barrolskii">
				GitHub.</a> I hope you enjoyed this little coding adventure and
				we'll see what I get up to when I post the next one.</p>

			</article>
		</main>

		<footer>
			<a href="https://github.com/barrolskii">
				<img src="../img/githubLogo.webp" alt="Github white logo" class="img-link" id="github-img">
			</a>

			<a href="https://www.linkedin.com/in/ashley-barrell-0a8804176/">
				<img src="../img/linkedInLogo.webp" alt="LinkedIn white logo" class="img-link" id="footer-img">
			</a>

			<a href="https://twitter.com/BarrellAshley">
				<img src="../img/twitterLogo.webp" alt="Twitter white logo" class="img-link" id="footer-img">
			</a>

		</footer>
	</body>

</html>
